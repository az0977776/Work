2/3/16

Image File Formats
   Compressed: smaller, less information
      png, gif, jpg
   Uncompressed: full map of pixel values
      bmp, tiff, svg, raw
   Lossy: loses some of the original information
      jpg
   Lossless: contains all the original information
      bmp, tiff, png

   Run-length Encoding
   12B GGGGGYYYRRRR
   6B  5G3Y4R

   Raster: image is represented as a grid of pixels
   Vector: image is represented as a list of drawing instructions, scale well

   netpbm: raster, lossless, uncompressed

------------------------------------------------------------------------------------------

2/4/16

netpbm (.ppm file)
   P3
   XRES YRES
   MAX_COLOR_VALUE
   RGB RGB RGB ...

All whitespace is equivalent

------------------------------------------------------------------------------------------

2/5/16

Bresenham's Line Algorithm
y = mx+b
f(x,y) = Ax+By+C = 0 when (x,y) on the line
first octant -> all lines have slopes between 0 and 1

------------------------------------------------------------------------------------------

2/9/16

Bresenham's Line Algorithm
A = Dy, B = -Dx, C = (Dx)b
F(x,y) = Ax+By+C
0<m<1

starting at (x,y), the next point in octant 1 is either (x+1,y) or (x+1,y+1)
mid point: (x+1,y+1/2)

if f(x+1,y+1/2)
= 0, then the midpoint is on the line and we can draw either pixel
< 0, then the line is below the midpoint and we draw the lower pixel (x+1,y)
> 0, then the line is above the midpoint and we draw the upper pixel (x+1,y+1)

First draw algorithm
(x0,y0) -> (x1,y1)
x=x0, y=y0
A = y1-y0
B = -(x1-x0)

d = A + B/2
while(x<=x1):
   plot(x,y)
   if (d > 0):
      y += 1
      d += B
   x += 1
   d += A

initial value of d
d = f(x0+1,y0+1/2)
d = A(x0+1) + B(y0+1/2) + C
d = Ax0 + A + By0 + B/2 + C
d = (Ax0 + By0 + C) + A + B/2
d = 0 + A + B/2

if d<0:
x->x+1, y->y
f(x+1,y)
d = A(x+1) + By + C
d = (Ax + By + C) + A
d = f(x,y) + A

if d>0:
x->x+1, y->y+1
f(x+1,y+1)
d = A(x+1) + B(y+1) + C
d = (Ax + By + C) + A + B
d = f(x,y) + A + B

------------------------------------------------------------------------------------------

2/10/16

d = A + B/2
2d = 2A + B

2d = 2d + 2A
2d = 2d + 2A + 2B

OCTANT I
d = 2A + B
while(x<=x0):
   plot(x,y)
   if (d>0):
      y+=1
      d+=2B
   x+=1
   d+=2A

OCTANT II
m>1
(x,y+1)
(x+1,y+1)
mp(x+1/2,y+1)
F(x0+1/2,y0+1)
Ax0+By0+C+A/2+B
Ax0+By0+C = 0 on the line
d = A/2 + B

if d < 0, then the line is to the right
if d > 0, then the line is to the left

d = A + 2B
while(y<=y1):
   plot(x,y)
   if (d<0):
      x+=1
      d+=2A
   y+=1
   d+=2B

OCTANT VIII
-1<m<0
(x+1,y)
(x+1,y-1)
mp (x+1,y-1/2)

f(x+1,y-1/2)

-----------------------------------------------------------------------------------------------
2/22/16

Using Matrices

Point Matrix
[p0,p1,p2,p3,p4,p5,p6]
Lists out each point

Edge Matrix
[p0p1,p1p2,p2p0]

[
x1,x2,x3,x4,x5,x6
y1,y2,y3,y4,y5,y6
z1,z2,z3,z4,z5,z6
1,1,1,1,1,1
]

Vertix Matrix
[p0p1p2,p1p0p2]
Shows every point that each point is connected to

-----------------------------------------------------------------------------------------------

2/23/16

Matrix Math Review
- Scalar Multiplication
- Matrix Multiplication
- Multiplicative Identity Matrix

Scalar Multiplication
S * [a b c d] = [Sa Sb Sc Sd]

Matrix Multiplication
- m0 * m1 != m1 * m0
- Number of columns in first == Number of rows in second
  [a b c] * [1 / 2 / 3] = [1a+2b+3c]
   1x3          3x1           1x1

   [a b c] * [1 / 2 / 3 | 4 / 5 / 6] = [1a+2b+3c 4a+5b+6c]
     1x3              3x2                     1x2

[
a b c
d e f
g h i
]
3x3

[
1 4
2 5
3 6
]
3x2

[
1a + 2b + 3c | 4a + 5b + 6c
1d + 2e + 3f | 4d + 5e + 6f
1g + 2h + 3i | 4g + 5h + 6i
]
3x2

Multiplicative Identity Matrix
- square matrix
- diagonal values are 1
- All others are 0

-----------------------------------------------------------------------------------------------

2/24/16

Transformation Matrices

Scaling
(x,y,z) --S(a,b,c)-> (ax,by,cz)

x y z 1
[
a 0 0 0
0 b 0 0
0 0 c 0
0 0 0 1
]
[x y z 1]
[ax by cz 1]
Scaling should take the center of dilation into account

Translating
(x,y,z) --T(a,b,c)-> (x+a,y+b,z+c)
x y z 1
[
1 0 0 a
0 1 0 b
0 0 1 c
0 0 0 1
]
[x y z 1]
[x+a y+b z+c 1]

Rotating
(x,y,z) --R(axis,theta)-> ( , , z)
x = rcos(phi)
y = rsin(phi)

xr = rsin(theta + phi) = rcos(phi)cos(thetha) - rsin(phi)sin(theta)
     		       	 xcosthetha
xr = xcos(theta) - ysin(theta)
yr = rsin(theta + phi) = rsin(phi)cos(theta) 
yr = xsin(theta) + ycos(theta)

=======================================================================================

2/25/16

(x,y,z) --R(z,theta)-> (xcos(theta)-ysin(theta),xsin(theta)+ycos(theta),z)
x    y   z 1
[
cos -sin 0 0
sin  cos 0 0
0    0   1 0
0    0   0 1
]

(x,y,z) --R(x,theta)-> (x,ycos(theta)-zsin(theta),ysin(theta)+zcos(theta))
x y    z   1
[
1 0    0   0
0 cos -sin 0
0 sin  cos 0
0 0    0   1
]

(x,y,z) --R(y,theta)-> (xcos(theta)-zsin(theta),y,xsin(theta)+zcos(theta))
x   y  z   1
[
cos 0 -sin 0
0   1  0   0
sin 0  cos 0
0   0  0   1
]

Applying Transformations:
E0: edge matrix
T: translation
S: scale
R: rotate

T*E0=E1 (affine transformation)
S*E1=E2 (translated->scaled)
R*E2=E3 (translated->scaled->rotate)
E3=R*S*T*E0

=======================================================================================

