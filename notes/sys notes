9/10/15
Aim: Time to C what we can do.

Do Now: What command line programs would do the following:
(always assume you are starting at your home directory)

1) Move foo.java from Desktop/ to Documents/
mv Desktop/foo.java Documents/

2) Remove all .class files
rm *.class

3) Connect to lisa.stuy.edu from somplace else
ssh aaron.wang@lisa.stuy.edu

4) Figure out what gcc does
man gcc

5) Copy woohoo.c from your home directory on lisa.stuy.edu to a /code/ directory on home (assume you are working on homer itself)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/11/15
Aim: C what I did there?

Do Now:
From yesterday:

4) Figure out what gcc does
man gcc

5) Copy woohoo.c from your home directory on lisa.stuy.edu to a /code/ directory on home (assume you are working on homer itself)
scp woohoo.c aaron.wang@homer.stuy.edu:/code/
scp (source) (destination) : directory

Today: List the java primitive variable types
int   32 bit integer
float   32 bit floating point number
boolean   true or false
char   character
short   16 bit integer
long   64 bit integer
double   64 bit floating point
byte   8 bit integer

Last Class Today!
Every day, 1 student will be chosen at random to provide a recap of the previous day's class. That evening, the same person will be responsible for posting the notes to the class piazza page. Make sure to tag the note as "last class today".

Title the note LCT <MM/DD WEEKDAY>
For example: LCT 9/10 Thursday

Also include at the end of the note a link to an interesting piece of tech/science news.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/16/15
Aim: Variables are the spice of life.

Do Now: What is the smallest variable type that could be used to store the following values (using standard sizes).
1) 5	byte	8-bit	-2^7 to 2^7-1
2) -30,000	short	16-bit	-2^15 to 2^15-1
3) 255	short
4) 5,000,000,000	long 64-bit	-2^31 to 2^31-1

byte	8-bit	-2^7 to 2^7-1
short	16-bit	-2^15 to 2^15-1
int	32-bit	-2^31 to 2^31-1
long	64-bit	-2^63 to 2^63-1

C Primitive Variable Types
	All C primitives are numeric.

	The only difference is floating point vs. integers and the size of the variables.

	Size can be platform dependent
		sizeof(<TYPE>) can be used to find the size in bytes
		sizeof(int)

Type	Standard Size (in bytes)
int	4
short	2
long	8
float	4
double	8
char	1

	All boolean values are numbers
		0 ==> false
		every other number ==> true

	YOU WILL ALL MAKE THIS MISTAKE:
		if (x=6) {...}
		should be x==6
		becomes if (6) {...} which is always true

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/17/15

Aim: Always read the fine print.

Do Now: Open up your editor of choice (emacs), write a basic "Hello World" program in java.

Data Types and Variables
	Character literals are single characters inside ''
		ex. 'a', '*' ...
	String literals exists, even though there is no String data type.
		ex. "hello", "you smell"

	Variables cannot be declared inside for loops statements but they can be initialized.

	Any variable type can be declared an "unsigned" variable. This signifies that the variable will never be negative.
	    The lower bound of any unsigned variable is 0.
	    The upper bound will be greater than the signed version.
	    ex. unsigned char x;
	    0 <= x <= 255
	
	java:
	public class Hello {
		public static void main(String[] args) {
			System.out.println( "Hello" );
		}
	}
./a.out
	c:
	int main() {	
		return 0;
	}

	gcc to compile the c file, produces an 'a.out' file
	use gcc <file> -o greeter to produce a file called greeter
	force 
	./a.out

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/17/15
SOTD: Superstitious - Stevie Wonder

Aim: A vast array of possibilities.

Do Now: How do you declare/use arrays in java?
String[] args

./a.out is required to force run the a.out file because linux does not allow random scripts to run

runtime errors
bust error
segmentation error: null pointer, array index, access nonexistent file, etc

c does not provide any functions
to use the printf() function, you must use
#include <stdio.h>
at the top of the file

#include <stdio.h>
in and out functions

#include <stdlib.h>
standard functions

#include "mylib.h"
for custom libraries

printf( "bob = %f\n", bob);
%f is placeholder for bob, the f is for float

printf does not add a newline at the end

If you want to print variables, you must include formatting placeholders in the string argument.
int i = 5;
printf("i is %d", i)

Type	  Formatting Character
int	  %d
long	  %ld
float	  %f
double	  %lf
	  %0,<x>f will provide x digits after the floating point
char	  %c
char array	%s
pointer		%p

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/22/15

SOTD: Hunger Strike - Temple of the Dog

Aim: What's the point of it all?

Memory Management
       Memory allocation either happens at compile time or at run time (dynamic).
       *java's new keyword creates dynamic memory (heap memory - objects)
       *compile time memory refers to java's stack memory (functions, variables, etc)

       Compiler Allocated Memory
       		Packaged with the binary of the program

		There is no standard default value. The memory you get might not be cleared. You should initialize variables.

		Variables and arrays are allocated here
			  ex) float a	 int b[5]

	Arrays
		Are not dynamic
		Must have a fixed size
		There is no length function
		There is no boundary checking
		*using a[-1] will refer to the memory at the location right before the start of the array

	segmentation fault can result from going to memory that you do not have access to
		

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/25/15

SOTD: Here Comes The HotStepper - Ini Kamoze

Aim: Ok, now we're really going to get to the point.

Pointers - Now the fun really starts
	 Variables designed to store memory addresses (think references in java)

	 32 bit system -> 4 bytes -> integer -> ~4x10^9, limited to 4gb ram
	 64 bit system -> 8 bytes -> long -> can have a bigger ram

   	 & is used to get the address of a variable

	 * is used to declare a variable as a pointer type
	      ex) int *p, double *q, char *r, ...
	      	  int *pfred = &fred; will hold the value of the pointer value of fred


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/28/15

//SOTD: Here Comes the Hotstepper - Ini Kamoze
SOTD: Lump - The Presidents of the United States of America

Aim: Ok, now we're really going to get to the point.

Do Now:
   1) Declare int, double and char variables.
   2) Declare int, double and char pointers. 
   3) Initialize each pointer to the address of the corresponding variable.
   4) Print out the pointer's value for each (as an unsigned long).
   5) Add 1 to each pointer.
   6) Print out the pointers again.
   What happened?

   char pointer adds 1
   int pointer adds 4
   long pointer adds 8
   void pointer adds 1

   Pointers - The fun really starts
   	    Variables designed to store memory addresses (think about references in java)

	    & is used to get the address of the variable

	    * is used to declare a variable as a pointer type
	      ex. int *p, double *q, char *r, ...

	    * is also used as the de-reference operator
	      It accesses the value at the memory location stored in a pointer

	    All pointer varialbe types are the same size

	    Pointer Arithmetic
	    	    int *p = &i;
		    char *c = &i

		    p++; // will add 4 to p
		    c++; // will add 1 to c

		    Array variavles are immutable pointers

	    Pointers can be assigned to array variables
	    	     int ray[5];
		     int *rp = ray;

		     ray[3] <==> ?
		     	    *(rp + 3)
			    
	       a[i] notation is shorthand for *(a + i)

	       a[i] <==> *(a + i)
	       i[a] <==> *(i + a)


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/29/15

SOTD: In The Meantime - Spacehog
Aim: Time to stop stringing you along.

fray
[2.3, 2, 8.17, .21, 5]
824  828  832
floats have 4 bytes

float fray[5];
float *fp = fray[0]; will give the pointer the value 2.3

float *fp = fray; is correct because the array variable is immutable and is the address of the array
printing fp will return 824 (the memory address)

*fp will return 2.3   dereference

address of the pointer is different from the address of the array

fp + 2 -> 832
*fp + 2 = 4.3
*(fp + 2) = 8.17

fp[2] <==> *(fp + 2) <==> *(2 + fp) <==> 2[fp]

you cannot modify the value of an array pointer (in this case, fray)

C strings (ctrings)
  Strings are character arrays that end with a null character (either '' or 0 or '/0')
  The terminating null character is a convention, string functions will not work correctly without it.

  The following are valid ways to declare strings:

      char s[256];
      	   Normal array declaration, allocates 256 bytes, nothing is set automatically.
      char s[256] = "Imagine";
      	   Allocates 256 bytes, puts "Imagine" in the first 7 bytes AND adds a null at the 8th byte
      char s[] = "Tuesday";
      	   Allocates 8 bytes, puts "Tuesday" in the first 7 bytes AND adds a null at the 8th byte


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/30/15

SOTD: One Headlight - The Wallflowers

Aim: How to write functioning code

Do Now: Write a c program that does the following
   1) Create a String and set it to some value
   2) Write code to find the length of the string and then print it. (Do not write a function for this)

   char *s = "Mankind";
   	Allocate 8 bytes, puts "Mankind" in the first 7 bytes AND adds a null at the 8th byte. s is a pointer variable instead of an array.

   You can only assign strings with = at declaration.
       char s[] = "zero"; //works
       s = "seven"; // does not work

   char *word = "cat";
   char *up = "dog";

   if you use
   up = word;
   then up will point to the same address that word points to(cat). dog is left somewhere in memory

   int size = 0;
   char *p = s4;
   while (*p++) {
   	 size ++;
	 }

   You should declare functions at the top of the c file
   int len( char *s);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/1/15

SOTD: Tom Sawyer - Rush

Aim: How to write functioning code

Functions: A brief interlude
   A parameter is a copy of the variable passed into the function. The original variable is not touched.

   function headers
      <return type> <name> (<parameters>)

   Can store functions in a header file (stringy.h)
   #include "stringy.h"
   in the c file

   void foo (char *s, int i);

   int x = 5;
   char *w = "cool";
   foo(w,x);

   when i is changed, x does not change
   *s = 'b' changes the values in the string
   the original values of x and w do not change
   all c functions are "pass by value"

   Back to Ctrings
      string.h
         C library that includes useful string functions.

	 All the functions assume that the parameter strings are always null-terminated.

	 int strlen( char *s) {
	    Returns the number of characters from the start of s up to the null character.

	 int strcmp( char *s1, char *s2)
	    compares two strings
	    negative if s1 > s2
	    positive if s1 < s2
	    0 if the two strings are the same

	 char * strcpy (char *dest, char *source)
	    copies source to destination

	 char * strcat (char *dest, char *source)
	    appends all the characters up to and including the terminating null from source to dest

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/6/15

SOTD: Fake Plastic Trees - Radiohead

Aim: Make it so

pointer to string does not work and declaring as an array works
string literals are immutable

char *s1 = "Hello";
char *s2 = "Hello";
char s3[] = "Hello";
s1 and s2 refer to the same immutable string literal
s3 refers to a different piece of memory that can be modified

immutable strings are stored in a place where c has fast access to them
&"Mankind" works and shows the address of the immutable string

cannot have two main functions; will not compile

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/7/15

SOTD: Fake Plastic Trees - Radiohead

Aim: Make it so

Seperate compilation
	 You can compile multiple c files into a c program by including them all in one gcc command.
	     gcc dwstring.c main.c
	 
	 You cannot have duplicate function or global variable names across these files. This includes the main() function

	 gcc -c
	     Will compile a c file into a .o file, it is not a fully functional program, but it is compiled code. Do this to compile a .c file that does not contain a main() function. <.o> files only have the compiled code
	 
	 gcc -c dwstring.c
	 gcc main.c dwstring.o
 	 combines the two files
	 
	 Make 
	      Create compiling instructions and setup dependencies
	      Standard name for the file is makefile

	      syntax:
		<TARGET>: <DEPENDENCIES>
		TAB<RULES>

	a.out: dwstring.o main.c
	   gcc dwstring.o main.c

	dwstring.o: dwstring.c dwstring.h
	   gcc -c dwstring.c

	main.o: main.c dwstring.h
	   gcc -c main.c	   

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/8/15

SOTD: Breaking The Girl - Red Hot Chili Peppers

Aim: If you can't (al)locate your memory then... I forget

A target in a make file can have any name

makefile -> checks if files are updated, compares times of files

clean:
	rm *.o
	rm *~

make run -> runs the file after the file is compiled

Dynamic memory allocation
   malloc(int x)
      Allocates x bytes of memory (from the heap)

      Returns the address at the beginning of the allocation
		   
      Returns a void *, always typecast to the correct pointer type.
		   
      int *p;
      p = (int *)malloc(20);
      P = (int *)malloc(5 * sizeof(int));

   calloc(int n, int x)
      Allocates n * x bytes of memory

      Ensures that each bit is set to 0
      
      Works like malloc in all other ways

      int *p;
      p = (int *)calloc(5, sizeof(int));

   realloc(void *p, int x)
      Changes the amount of memory allocated to a given block.

      p must be a pointer to the beginning of an allocated block of memory, but it does not have to be the original pointer.

      If x is smaller than the original size of the allocation, the extra bytes will be released.

      int *p;
      p = (int *)malloc(20);
      p = (int *)realloc(p, 40);
      
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/9/15

SOTD: Papa's Got a Brand New Bag - James Brown

Aim: Always structure your code well.

Dynamic Memory Allocation
   Normal memory allocation happens on the stack.

   Stack memory get released as functions pop off.

   Dynamic memory is located on the heap, it persists even after the function that created it pops off the stack.

   You must manually release dynamically allocated memory from the heap.

   free
      Releases dynamically allocated memory.

      Takes one parameter, a pointer to the beginning of a dynamically allocated block of memory.

      Every call to malloc/calloc should have a corresponding call to free.

      int *p;
      p = (int *)malloc(20);
      free(p);

   Typedef
      Provide a new name for a existing data type.
      Can be put into the .h header file
      typedef <original type> <new name>;
      
      typedef float bubbles;
      typedef char * String;

   Struct
      A collection of values in a single data type.

      struct { int a; char x; } s;
      struct { int a; char x; } t;

      t.a = 97;
      t.x = '@';

      // struct foo { int a; char c; };
      typedef struct { int a; char c; } foo;
      foo *t;
      t = (foo *)malloc(sizef)

      (*t).a;
      t->c = '@';

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/13/15

SOTD: Low Rider - War

Aim: Zelda's in trouble, get Link!

Do Now: What's wrong with this function?
(Assume node has been declared correctly)

node* insert_front( node* n, int i) {
      node new;
      new.i = i;
      new.next = n;
      return &new;
}

FROM HOMEWORK:

typedef struct n {
   int i;
   struct n* next;
} node;
because struct n is in the struct n, you typedef on the same line

void print_list( node* );
do not need variable names for the parameters in the header file

SNAKE CASE
named with lowercase seperated by underscores

stack memory is freed after function completes
heap memory stays

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/15/15

#define FOO 27
before compiling, replaces all FOO in file with 27

#ifndef FOO
#endif
if FOO not defined, then run everything in between #ifndef and #endif

#ifndef LINK_LIST_H
#define LINK_LIST_H

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/20/15

SOTD: Wheels - Cake

Aim: File this under useful information.

Do Now: What are the different kinds of files permissions?

read
write
execute

who has this permission?

rand()
will return the same numbers

srand(<seed>)
returns random numbers based on the seed

sranddev()
seeds random number generator with a random number, truly "random"

File Permission
   3 kinds of permissions
      read, write, execute
      binary switch
      1	  0   0  is 4; read-only
      1   0   1  is 5; read and execute
      1   1   1  is 7; read, write and execute
   Permissions can be represented as 3-digit binary #'s, or 1-digit octal #'s

   There are 3 permission "areas"
      user, group, others
      no overlap between the three groups

   each area can have its own permissions:

   644 => user:read + write, group: read, other: read
   6 = read and write
   4 = read

   chmod 600 foo
   change foo to user:read and write only
   user can always change the permission of the file

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/21/15

Note: Don't compile .h files!

SOTD: Everything - MrNorth

Aim: Opening up a whole new world of possibilities.

chown
to change the owner of the file

chgrp
to change the group of the file

File Table
   A list of all files used by a program while it is running.
   Contains basic information like the file's location and size.
   The file table has a limited size, which is a power of 2 and is commonly 256.
   getdtablesize() will return the size of the file table.
   Each file is a given an integer index, starting at 0, this is referred to as the file descriptor.

   There are 3 files that are always open in the table:
   0 or STDIN_FILENO: stdin
   1 or STDOUT_FILENO: stdout
   2 or STDERR_FILENO: stderr

open - <fcntl.h>
   Add a file to the file table and returns its file descriptor
   fd1 = open( "foo", 1 );
   fd1 returns 3 because there are already 3 files in the file table
   the descriptor to non-existant files is -1

   If open fails, -1 is returned, extra error information cna be found in errno
   #include <errno.h>
      errno is an int variable that can be found in <errno.h>, using strerror in <string.h> on errno will return a string description of the error.
      strerror(errno);

open( <PATH>, <FLAGS>, <MODE> )

mode
   Only used when creating a file. Set the new file's permission using a 3-digit octal #.
   Octal #'s have a leading 0
      0644, 0777

flags
   Determine what you plan to do with the file.
   Use the following constants:
      O_RDONLY
      O_WRONLY
      O_RDWR
      O_APPEND
      O_TRUNC
      O_CREAT
      O_EXCL: when combined with O_CREAT, will return an error if the file exists

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/22/15

SOTD: Fly Me To The Moon - Frank Sinatra

Aim: Read your writes!

open
   flags
      Determine what you plan to do with the file.

      Use the following constants:
      	  O_RDONLY
	  O_WRONLY
	  O_RDWR
	  O_APPEND
	  O_TRUNC
	  O_CREAT
	  O_EXCL: when combined with O_CREAT, will return an error if the file exists

   bitwise operators
      &: bitwise and
      |: bitwise or
      ~: bitwise not
      ^: bitwise xor

   char c = 13; // 00001101
   char x = ~c; // 11110010

   flags
      Each flag is a number, to combine flags we use bitwise or

      O_WRONLY = 1        = 000000001
      O_APPEND = 8        = 000001000
      O_WRONLY | O_APPEND = 000001001
      use the operator on each column

   close - <unistd.h>
      Remove a file from the file table.

      Returns 0 if successful. Returns -1 and sets errno if unsuccessful.

      close(<FILE DESCRIPTOR>);
      
read - <unistd.h>
   Read in data from a file

   read( <FILE DESCRIPTOR>, <BUFFER>, <AMOUNT> );
   read( fd, buff, n)

   Reads n bytes from the fd's file and put that data into buff
   Returns the number of bytes actually read. Returns -1 and sets errno if unsuccessful.

   BUFFER must be a pointer. If you do not put a pointer, the BUFFER cannot be modified; functions have pass-by values.

write - <unistd.h>
   write( <FILE DESCRIPTOR >, <BUFFER>, <AMOUT> );   

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/26/15

SOTD: Crazy - Gnarls Barkley

Aim: Seek and ye shall find

umask(0111);
shuts down execute permission for all files

umask(0000);
all permissions are available

umask(0022);
group and others cannot write

lseek - <unistd.h>
   Set the current position in a open file
   lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )
   whence is where you are measuring from

   SEEK_SET
      offset is evaluated from the beginning of the file

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/28/15

SOTD: For What It's Worth - Buffalo Springfield

Aim: I need information, stat!

Do Now:
   1) Make a directory
   2) Put a few files in that directory and maybe even a directory or two

metadata is data that describes other data
a file has 40 bytes, the information that it has 40 bytes is not in the actual file

ls is written in c

stat - <sys/stat.h>
   Get information about a file (metadata)

   stat(<PATH>, <STAT BUFFER>)
   
      struct stat sb;
      stat("foo", %sb);
      
   <STAT BUFFER>
      Must be a pointer to a struct stat
      All the file information gets put into the stat buffer. 
      Some of the fields in struct stat:
         st_size
	    file size in bytes
         st_uid, st_gid
	    user id, group id
         st_mode
            file permissions
         st_atime, st_mtime
  	    last access, last modification
	    
	    These are stuct time_t variables. We can use functions in time.h to make sense of them.
	    
	    ctime(<struct time_t *>) 
	       returns the time as a string

	    time(<struct time_t *>)
 	       sets the parameter to the current time

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////