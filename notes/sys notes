9/10/15
Aim: Time to C what we can do.

Do Now: What command line programs would do the following:
(always assume you are starting at your home directory)

1) Move foo.java from Desktop/ to Documents/
mv Desktop/foo.java Documents/

2) Remove all .class files
rm *.class

3) Connect to lisa.stuy.edu from somplace else
ssh aaron.wang@lisa.stuy.edu

4) Figure out what gcc does
man gcc

5) Copy woohoo.c from your home directory on lisa.stuy.edu to a /code/ directory on home (assume you are working on homer itself)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/11/15
Aim: C what I did there?

Do Now:
From yesterday:

4) Figure out what gcc does
man gcc

5) Copy woohoo.c from your home directory on lisa.stuy.edu to a /code/ directory on home (assume you are working on homer itself)
scp woohoo.c aaron.wang@homer.stuy.edu:/code/
scp (source) (destination) : directory

Today: List the java primitive variable types
int   32 bit integer
float   32 bit floating point number
boolean   true or false
char   character
short   16 bit integer
long   64 bit integer
double   64 bit floating point
byte   8 bit integer

Last Class Today!
Every day, 1 student will be chosen at random to provide a recap of the previous day's class. That evening, the same person will be responsible for posting the notes to the class piazza page. Make sure to tag the note as "last class today".

Title the note LCT <MM/DD WEEKDAY>
For example: LCT 9/10 Thursday

Also include at the end of the note a link to an interesting piece of tech/science news.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/16/15
Aim: Variables are the spice of life.

Do Now: What is the smallest variable type that could be used to store the following values (using standard sizes).
1) 5	byte	8-bit	-2^7 to 2^7-1
2) -30,000	short	16-bit	-2^15 to 2^15-1
3) 255	short
4) 5,000,000,000	long 64-bit	-2^31 to 2^31-1

byte	8-bit	-2^7 to 2^7-1
short	16-bit	-2^15 to 2^15-1
int	32-bit	-2^31 to 2^31-1
long	64-bit	-2^63 to 2^63-1

C Primitive Variable Types
	All C primitives are numeric.

	The only difference is floating point vs. integers and the size of the variables.

	Size can be platform dependent
		sizeof(<TYPE>) can be used to find the size in bytes
		sizeof(int)

Type	Standard Size (in bytes)
int	4
short	2
long	8
float	4
double	8
char	1

	All boolean values are numbers
		0 ==> false
		every other number ==> true

	YOU WILL ALL MAKE THIS MISTAKE:
		if (x=6) {...}
		should be x==6
		becomes if (6) {...} which is always true

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/17/15

Aim: Always read the fine print.

Do Now: Open up your editor of choice (emacs), write a basic "Hello World" program in java.

Data Types and Variables
	Character literals are single characters inside ''
		ex. 'a', '*' ...
	String literals exists, even though there is no String data type.
		ex. "hello", "you smell"

	Variables cannot be declared inside for loops statements but they can be initialized.

	Any variable type can be declared an "unsigned" variable. This signifies that the variable will never be negative.
	    The lower bound of any unsigned variable is 0.
	    The upper bound will be greater than the signed version.
	    ex. unsigned char x;
	    0 <= x <= 255
	
	java:
	public class Hello {
		public static void main(String[] args) {
			System.out.println( "Hello" );
		}
	}
./a.out
	c:
	int main() {	
		return 0;
	}

	gcc to compile the c file, produces an 'a.out' file
	use gcc <file> -o greeter to produce a file called greeter
	force 
	./a.out

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/17/15
SOTD: Superstitious - Stevie Wonder

Aim: A vast array of possibilities.

Do Now: How do you declare/use arrays in java?
String[] args

./a.out is required to force run the a.out file because linux does not allow random scripts to run

runtime errors
bust error
segmentation error: null pointer, array index, access nonexistent file, etc

c does not provide any functions
to use the printf() function, you must use
#include <stdio.h>
at the top of the file

#include <stdio.h>
in and out functions

#include <stdlib.h>
standard functions

#include "mylib.h"
for custom libraries

printf( "bob = %f\n", bob);
%f is placeholder for bob, the f is for float

printf does not add a newline at the end

If you want to print variables, you must include formatting placeholders in the string argument.
int i = 5;
printf("i is %d", i)

Type	  Formatting Character
int	  %d
long	  %ld
float	  %f
double	  %lf
	  %0,<x>f will provide x digits after the floating point
char	  %c
char array	%s
pointer		%p

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/22/15

SOTD: Hunger Strike - Temple of the Dog

Aim: What's the point of it all?

Memory Management
       Memory allocation either happens at compile time or at run time (dynamic).
       *java's new keyword creates dynamic memory (heap memory - objects)
       *compile time memory refers to java's stack memory (functions, variables, etc)

       Compiler Allocated Memory
       		Packaged with the binary of the program

		There is no standard default value. The memory you get might not be cleared. You should initialize variables.

		Variables and arrays are allocated here
			  ex) float a	 int b[5]

	Arrays
		Are not dynamic
		Must have a fixed size
		There is no length function
		There is no boundary checking
		*using a[-1] will refer to the memory at the location right before the start of the array

	segmentation fault can result from going to memory that you do not have access to
		

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/25/15

SOTD: Here Comes The HotStepper - Ini Kamoze

Aim: Ok, now we're really going to get to the point.

Pointers - Now the fun really starts
	 Variables designed to store memory addresses (think references in java)

	 32 bit system -> 4 bytes -> integer -> ~4x10^9, limited to 4gb ram
	 64 bit system -> 8 bytes -> long -> can have a bigger ram

   	 & is used to get the address of a variable

	 * is used to declare a variable as a pointer type
	      ex) int *p, double *q, char *r, ...
	      	  int *pfred = &fred; will hold the value of the pointer value of fred


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/28/15

//SOTD: Here Comes the Hotstepper - Ini Kamoze
SOTD: Lump - The Presidents of the United States of America

Aim: Ok, now we're really going to get to the point.

Do Now:
   1) Declare int, double and char variables.
   2) Declare int, double and char pointers. 
   3) Initialize each pointer to the address of the corresponding variable.
   4) Print out the pointer's value for each (as an unsigned long).
   5) Add 1 to each pointer.
   6) Print out the pointers again.
   What happened?

   char pointer adds 1
   int pointer adds 4
   long pointer adds 8
   void pointer adds 1

   Pointers - The fun really starts
   	    Variables designed to store memory addresses (think about references in java)

	    & is used to get the address of the variable

	    * is used to declare a variable as a pointer type
	      ex. int *p, double *q, char *r, ...

	    * is also used as the de-reference operator
	      It accesses the value at the memory location stored in a pointer

	    All pointer varialbe types are the same size

	    Pointer Arithmetic
	    	    int *p = &i;
		    char *c = &i

		    p++; // will add 4 to p
		    c++; // will add 1 to c

		    Array variavles are immutable pointers

	    Pointers can be assigned to array variables
	    	     int ray[5];
		     int *rp = ray;

		     ray[3] <==> ?
		     	    *(rp + 3)
			    
	       a[i] notation is shorthand for *(a + i)

	       a[i] <==> *(a + i)
	       i[a] <==> *(i + a)


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/29/15

SOTD: In The Meantime - Spacehog
Aim: Time to stop stringing you along.

fray
[2.3, 2, 8.17, .21, 5]
824  828  832
floats have 4 bytes

float fray[5];
float *fp = fray[0]; will give the pointer the value 2.3

float *fp = fray; is correct because the array variable is immutable and is the address of the array
printing fp will return 824 (the memory address)

*fp will return 2.3   dereference

address of the pointer is different from the address of the array

fp + 2 -> 832
*fp + 2 = 4.3
*(fp + 2) = 8.17

fp[2] <==> *(fp + 2) <==> *(2 + fp) <==> 2[fp]

you cannot modify the value of an array pointer (in this case, fray)

C strings (ctrings)
  Strings are character arrays that end with a null character (either '' or 0 or '/0')
  The terminating null character is a convention, string functions will not work correctly without it.

  The following are valid ways to declare strings:

      char s[256];
      	   Normal array declaration, allocates 256 bytes, nothing is set automatically.
      char s[256] = "Imagine";
      	   Allocates 256 bytes, puts "Imagine" in the first 7 bytes AND adds a null at the 8th byte
      char s[] = "Tuesday";
      	   Allocates 8 bytes, puts "Tuesday" in the first 7 bytes AND adds a null at the 8th byte


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

9/30/15

SOTD: One Headlight - The Wallflowers

Aim: How to write functioning code

Do Now: Write a c program that does the following
   1) Create a String and set it to some value
   2) Write code to find the length of the string and then print it. (Do not write a function for this)

   char *s = "Mankind";
   	Allocate 8 bytes, puts "Mankind" in the first 7 bytes AND adds a null at the 8th byte. s is a pointer variable instead of an array.

   You can only assign strings with = at declaration.
       char s[] = "zero"; //works
       s = "seven"; // does not work

   char *word = "cat";
   char *up = "dog";

   if you use
   up = word;
   then up will point to the same address that word points to(cat). dog is left somewhere in memory

   int size = 0;
   char *p = s4;
   while (*p++) {
   	 size ++;
	 }

   You should declare functions at the top of the c file
   int len( char *s);

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/1/15

SOTD: Tom Sawyer - Rush

Aim: How to write functioning code

Functions: A brief interlude
   A parameter is a copy of the variable passed into the function. The original variable is not touched.

   function headers
      <return type> <name> (<parameters>)

   Can store functions in a header file (stringy.h)
   #include "stringy.h"
   in the c file

   void foo (char *s, int i);

   int x = 5;
   char *w = "cool";
   foo(w,x);

   when i is changed, x does not change
   *s = 'b' changes the values in the string
   the original values of x and w do not change
   all c functions are "pass by value"

   Back to Ctrings
      string.h
         C library that includes useful string functions.

	 All the functions assume that the parameter strings are always null-terminated.

	 int strlen( char *s) {
	    Returns the number of characters from the start of s up to the null character.

	 int strcmp( char *s1, char *s2)
	    compares two strings
	    negative if s1 > s2
	    positive if s1 < s2
	    0 if the two strings are the same

	 char * strcpy (char *dest, char *source)
	    copies source to destination

	 char * strcat (char *dest, char *source)
	    appends all the characters up to and including the terminating null from source to dest

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/6/15

SOTD: Fake Plastic Trees - Radiohead

Aim: Make it so

pointer to string does not work and declaring as an array works
string literals are immutable

char *s1 = "Hello";
char *s2 = "Hello";
char s3[] = "Hello";
s1 and s2 refer to the same immutable string literal
s3 refers to a different piece of memory that can be modified

immutable strings are stored in a place where c has fast access to them
&"Mankind" works and shows the address of the immutable string

cannot have two main functions; will not compile

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/7/15

SOTD: Fake Plastic Trees - Radiohead

Aim: Make it so

Seperate compilation
	 You can compile multiple c files into a c program by including them all in one gcc command.
	     gcc dwstring.c main.c
	 
	 You cannot have duplicate function or global variable names across these files. This includes the main() function

	 gcc -c
	     Will compile a c file into a .o file, it is not a fully functional program, but it is compiled code. Do this to compile a .c file that does not contain a main() function. <.o> files only have the compiled code
	 
	 gcc -c dwstring.c
	 gcc main.c dwstring.o
 	 combines the two files
	 
	 Make 
	      Create compiling instructions and setup dependencies
	      Standard name for the file is makefile

	      syntax:
		<TARGET>: <DEPENDENCIES>
		TAB<RULES>

	a.out: dwstring.o main.c
	   gcc dwstring.o main.c

	dwstring.o: dwstring.c dwstring.h
	   gcc -c dwstring.c

	main.o: main.c dwstring.h
	   gcc -c main.c	   

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/8/15

SOTD: Breaking The Girl - Red Hot Chili Peppers

Aim: If you can't (al)locate your memory then... I forget

A target in a make file can have any name

makefile -> checks if files are updated, compares times of files

clean:
	rm *.o
	rm *~

make run -> runs the file after the file is compiled

Dynamic memory allocation
   malloc(int x)
      Allocates x bytes of memory (from the heap)

      Returns the address at the beginning of the allocation
		   
      Returns a void *, always typecast to the correct pointer type.
		   
      int *p;
      p = (int *)malloc(20);
      P = (int *)malloc(5 * sizeof(int));

   calloc(int n, int x)
      Allocates n * x bytes of memory

      Ensures that each bit is set to 0
      
      Works like malloc in all other ways

      int *p;
      p = (int *)calloc(5, sizeof(int));

   realloc(void *p, int x)
      Changes the amount of memory allocated to a given block.

      p must be a pointer to the beginning of an allocated block of memory, but it does not have to be the original pointer.

      If x is smaller than the original size of the allocation, the extra bytes will be released.

      int *p;
      p = (int *)malloc(20);
      p = (int *)realloc(p, 40);
      
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/9/15

SOTD: Papa's Got a Brand New Bag - James Brown

Aim: Always structure your code well.

Dynamic Memory Allocation
   Normal memory allocation happens on the stack.

   Stack memory get released as functions pop off.

   Dynamic memory is located on the heap, it persists even after the function that created it pops off the stack.

   You must manually release dynamically allocated memory from the heap.

   free
      Releases dynamically allocated memory.

      Takes one parameter, a pointer to the beginning of a dynamically allocated block of memory.

      Every call to malloc/calloc should have a corresponding call to free.

      int *p;
      p = (int *)malloc(20);
      free(p);

   Typedef
      Provide a new name for a existing data type.
      Can be put into the .h header file
      typedef <original type> <new name>;
      
      typedef float bubbles;
      typedef char * String;

   Struct
      A collection of values in a single data type.

      struct { int a; char x; } s;
      struct { int a; char x; } t;

      t.a = 97;
      t.x = '@';

      // struct foo { int a; char c; };
      typedef struct { int a; char c; } foo;
      foo *t;
      t = (foo *)malloc(sizef)

      (*t).a;
      t->c = '@';

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/13/15

SOTD: Low Rider - War

Aim: Zelda's in trouble, get Link!

Do Now: What's wrong with this function?
(Assume node has been declared correctly)

node* insert_front( node* n, int i) {
      node new;
      new.i = i;
      new.next = n;
      return &new;
}

FROM HOMEWORK:

typedef struct n {
   int i;
   struct n* next;
} node;
because struct n is in the struct n, you typedef on the same line

void print_list( node* );
do not need variable names for the parameters in the header file

SNAKE CASE
named with lowercase seperated by underscores

stack memory is freed after function completes
heap memory stays

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/15/15

#define FOO 27
before compiling, replaces all FOO in file with 27

#ifndef FOO
#endif
if FOO not defined, then run everything in between #ifndef and #endif

#ifndef LINK_LIST_H
#define LINK_LIST_H

#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/20/15

SOTD: Wheels - Cake

Aim: File this under useful information.

Do Now: What are the different kinds of files permissions?

read
write
execute

who has this permission?

rand()
will return the same numbers

srand(<seed>)
returns random numbers based on the seed

sranddev()
seeds random number generator with a random number, truly "random"

File Permission
   3 kinds of permissions
      read, write, execute
      binary switch
      1	  0   0  is 4; read-only
      1   0   1  is 5; read and execute
      1   1   1  is 7; read, write and execute
   Permissions can be represented as 3-digit binary #'s, or 1-digit octal #'s

   There are 3 permission "areas"
      user, group, others
      no overlap between the three groups

   each area can have its own permissions:

   644 => user:read + write, group: read, other: read
   6 = read and write
   4 = read

   chmod 600 foo
   change foo to user:read and write only
   user can always change the permission of the file

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/21/15

Note: Don't compile .h files!

SOTD: Everything - MrNorth

Aim: Opening up a whole new world of possibilities.

chown
to change the owner of the file

chgrp
to change the group of the file

File Table
   A list of all files used by a program while it is running.
   Contains basic information like the file's location and size.
   The file table has a limited size, which is a power of 2 and is commonly 256.
   getdtablesize() will return the size of the file table.
   Each file is a given an integer index, starting at 0, this is referred to as the file descriptor.

   There are 3 files that are always open in the table:
   0 or STDIN_FILENO: stdin
   1 or STDOUT_FILENO: stdout
   2 or STDERR_FILENO: stderr

open - <fcntl.h>
   Add a file to the file table and returns its file descriptor
   fd1 = open( "foo", 1 );
   fd1 returns 3 because there are already 3 files in the file table
   the descriptor to non-existant files is -1

   If open fails, -1 is returned, extra error information cna be found in errno
   #include <errno.h>
      errno is an int variable that can be found in <errno.h>, using strerror in <string.h> on errno will return a string description of the error.
      strerror(errno);

open( <PATH>, <FLAGS>, <MODE> )

mode
   Only used when creating a file. Set the new file's permission using a 3-digit octal #.
   Octal #'s have a leading 0
      0644, 0777

flags
   Determine what you plan to do with the file.
   Use the following constants:
      O_RDONLY
      O_WRONLY
      O_RDWR
      O_APPEND
      O_TRUNC
      O_CREAT
      O_EXCL: when combined with O_CREAT, will return an error if the file exists

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/22/15

SOTD: Fly Me To The Moon - Frank Sinatra

Aim: Read your writes!

open
   flags
      Determine what you plan to do with the file.

      Use the following constants:
      	  O_RDONLY
	  O_WRONLY
	  O_RDWR
	  O_APPEND
	  O_TRUNC
	  O_CREAT
	  O_EXCL: when combined with O_CREAT, will return an error if the file exists

   bitwise operators
      &: bitwise and
      |: bitwise or
      ~: bitwise not
      ^: bitwise xor

   char c = 13; // 00001101
   char x = ~c; // 11110010

   flags
      Each flag is a number, to combine flags we use bitwise or

      O_WRONLY = 1        = 000000001
      O_APPEND = 8        = 000001000
      O_WRONLY | O_APPEND = 000001001
      use the operator on each column

   close - <unistd.h>
      Remove a file from the file table.

      Returns 0 if successful. Returns -1 and sets errno if unsuccessful.

      close(<FILE DESCRIPTOR>);
      
read - <unistd.h>
   Read in data from a file

   read( <FILE DESCRIPTOR>, <BUFFER>, <AMOUNT> );
   read( fd, buff, n)

   Reads n bytes from the fd's file and put that data into buff
   Returns the number of bytes actually read. Returns -1 and sets errno if unsuccessful.

   BUFFER must be a pointer. If you do not put a pointer, the BUFFER cannot be modified; functions have pass-by values.

write - <unistd.h>
   write( <FILE DESCRIPTOR >, <BUFFER>, <AMOUT> );   

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/26/15

SOTD: Crazy - Gnarls Barkley

Aim: Seek and ye shall find

umask(0111);
shuts down execute permission for all files

umask(0000);
all permissions are available

umask(0022);
group and others cannot write

lseek - <unistd.h>
   Set the current position in a open file
   lseek( <FILE DESCRIPTOR>, <OFFSET>, <WHENCE> )
   whence is where you are measuring from

   SEEK_SET
      offset is evaluated from the beginning of the file

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/28/15

SOTD: For What It's Worth - Buffalo Springfield

Aim: I need information, stat!

Do Now:
   1) Make a directory
   2) Put a few files in that directory and maybe even a directory or two

metadata is data that describes other data
a file has 40 bytes, the information that it has 40 bytes is not in the actual file

ls is written in c

stat - <sys/stat.h>
   Get information about a file (metadata)

   stat(<PATH>, <STAT BUFFER>)
   
      struct stat sb;
      stat("foo", %sb);
      
   <STAT BUFFER>
      Must be a pointer to a struct stat
      All the file information gets put into the stat buffer. 
      Some of the fields in struct stat:
         st_size
	    file size in bytes
         st_uid, st_gid
	    user id, group id
         st_mode
            file permissions
         st_atime, st_mtime
  	    last access, last modification
	    
	    These are stuct time_t variables. We can use functions in time.h to make sense of them.
	    
	    ctime(<struct time_t *>) 
	       returns the time as a string

	    time(<struct time_t *>)
 	       sets the parameter to the current time

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/29/15

SOTD: In the Waiting Line - Zero 7

Aim: Where do compsci priests live? - In directory!

ctime( <TIME> )
   TIME is the type time_t*
   returns the time as a string

time( <TIME> )
   TIME is type time_t*
   sets the parameter to the current time

   time_t t;
   time(&t);
   printf("%lu\n", t);
   printf("%s\n", t);

Directories
   A *nix directory is a file containing the names of the files within the directory along with the basic information like file type.

   Moving files into/out of a directory means changing the directory file, not actually moving any data.

opendir - <dirent.h>
   Open a directory file
   This will not change the cwd, it only allows your program to read the contents of the directory file

opendir(<PATH>);
   Returns a pointer to a directory stream (DIR *)

closedir - <dirent.h>
   Closes the directory stream and frees the pointer associated with it.
   closedir(<DIRECTORY STREAM>)

readdir - <dirent.h>
   readdir(<DIRECTORY STREAM>)
   Returns a pointer to the next entry in a directory stream, or NULL if all entries have already been returned.

   struct dirent - <sys/types.h>
   Directory struct that contains the information stored in a directory file.

   Some of the data members
      d_name: Name of a file 
      d_type: File type as an int

   example:
      DIR * d;
      d = opendir("somedir");

      struct dirent *entry;
      entry = readdir(d);

rewinddir = <dirent.h>
   Resets the directory stream to the beginning

   rewinddir(<DIRECTORY STREAM>)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

10/30/15

SOTD: War Pigs - Black Sabbath

Aim: Puttin' in the puts.

Command Line Arguments:
   int main( int argc, char *argv[])

   program name is considered the first command line argument

   argc
      number of command line arguments
   argv
      array of command line arguments

scanf - <stdio.h>
   scanf(<FORMAT STRING>, <VAR1>, <VAR2>, ...)
   Reads in data from stdin using the format string to determine types.
   Puts the data in each variable.
   Variables must be pointers.

   int x; float f; double d;
   scanf("%d %f %lf", &x, &f, &d);

fgets - <stdio.h>
   Reads in from a file stream and stores is in a string
   fgets(<DESTINATION>, <BYTES>, <FILE POINTER>);
   retains the newline and puts a terminating null
   saves the last byte for the terminating null
   
   fgets(s, n, f);
      Reads at most n-1 characters from the file stream f and stores it in s
   File pointer
      FILE * type, more complex than a file descriptor
      stdin is a FILE * variable
   Stops at newline, end of file, or the byte limit

   Keeps the newline character as part of the string, appends NULL after.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

11/4/15

SOTD: Shine - Collection Soul

Aim: Are your processes running? - Then you should go out and catch them!

Do Now: Run the command ps in a terminal. What do you see?

Processes
   Every running program is a process. A process can create subprocesses, but these are no different from regular processes.
   A processor can handle 1 process per cycle (per core). "Multitasking" appears to happen because the processor switches between all the active processes quickly.
   
   pid
      Every process has an unique identifier called the pid.
      pid 1 is the init process
      Each entry in the /proc directory is a current pid

   getpid() - <unistd.h>
      returns the current process's pid
      
   getppid() - <unistd.h>
      returns the current process's parent pid

   fork() - <unistd.h>
      Creates a seperate process based on the current one, the new process is called the child, the original is the parent.
      The child process is a duplicate of the parent process. All parts of the parent process are copied, including stack and heap memory, and the file table.

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

11/5/15

SOTD: Us and Them - Pink Floyd

Aim: Go fork off (another process)

fork() - <unistd.h>
   Creates a seperate process based on the current one, the new process is called the child, the original is the parent.
   The child process is a duplicate of the parent process. All parts of the parent process are copied, including stack and heap memory, and the file table.
      Quick note on threads: A thread is a seperate executable entity similar to a child process, except a thread is not a standalone process. It does not have its own        memory space, instead it shares its parent's memory.
   Returns 0 to the child and the child's pid to the parent or -1(errno).
   If a parent process ends before the child, the child's new parent pid is 1.

wait() - <unistd.h>
   Stops a parent process from running until any child has provided status information to the parent (usually the child has exited).
   Returns the pid of the child that exited, or -1(errno)
   
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

11/9/15

SOTD: Losing My Religion - REM

Aim: Time to bring out the executioner.

exit( <int> ) 
exits the process and returns the integer in the parameter

waitpid( <pid>, &status, 0)
will wait until the pid given finishes

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

11/10/15

SOTD: Burden in my Hand - Soundgarden

Aim: Invasion of the process snatchers.

waitpid - <unistd.h>
   Waits for a specific child
   waitpid(pid, status, options)
      pid
         The pid of the specific child to look for. If -1, will wait for any child
      	 waitpid(-1,status,0) works just like wait()
      options
         Can set other behavior for wait, if 0, will work normally

The exec family - <unistd.h>
   There are a number of c functions that can be used to run other programs from within our own programs.
   Replaces the current process with the new program, any code after a call to an exec function will be ignored.
   
   execl
      execl(<PATH>, <COMMAND>, <ARGS>, NULL)
      
      PATH
         The path to the program (ex: "/bin/ls")
      COMMAND
         The name of the program (ex: :"ls")
      ARGS
         Each command line arguemnt you wish to give to the program. (ex: "-a", "-l")
	 The last argument must be NULL
      example
         execl("/bin/ls", "ls", "-a", "-l", NULL);
      
   execlp
      execlp(<PATH>, <COMMAND>, <ARGS>, NULL>
         Works like execl, except it uses the PATH enviroment variable for commands, so you can use "ls" as the PATH instead of "/bin/ls"
      example
	 execlp("ls", "ls", "-a", "-l", NULL);

   execvp
      execvp(<PATH>, <ARGUMENT ARRAY>)
      ARGUMENT ARRAY
         Array of strings, with element 0 as the name of the program to be executed and the last element must be NULL.
      Like execlp, the PATH argument will take the PATH enviroment variable into account.     

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

11/12/15

SOTD: Sell Out - Reel Big Fish

Aim: Let's take this to delimit!

strsep - <string.h>
   Used for parsing a string with a common delimiter
   strsep( <SOURCE>, <DELIMITER> )
   Locates the first occurrence of the delimiter in a string and replaces that character with NULL.
   Returns the beginning of the original string and sets the source string to the string starting at 1 index past the location of the new NULL.
   Since the source varialbe's value is changed, it must be a pointer to a string.
   char line[100] = "wow-this-is-cool"
   char *s1 = line;

   strsep( &s1, "-")
      replaces the - after the wow with NULL
      returns "wow"
      sets s1 to "this-is-cool"
      when &s1 is NULL, then you have reached the end of the string

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

11/16/15

SOTD: Gimmie Shelter - The Rolling Stone

Aim: Redirection, how does it ... SQUIRREL

File Redirection
   Changing the usual input/output behavior of a program
   Command line redirection
      >
         Redirects stdout to a file
	 Overwrites the content of the file
	 <COMMAND> <FILE>
	 ls > file_list
      >> 
         Redirects stdout to a file
	 Appends instead of overwrites

      2>
         Redirects stderr to a file
	 Overwrites the file (2>> appends)
      
      &>
         Redirects stdout and stderr

      <
         Redirects stdin from a file

      | (pipe)
         Redirects stdout from one command to stdin of the next
	 ls | wc
	    word counts ls output

   Redirection in c programs
      dup2 - <unistd.h>
         Redirects one file descriptor to another
	 dup2(fd1,fd2)
	    Redirects fd2 to fd1
	    puts fd1 into fd2   


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

11/30/15

SOTD: Billie Jean - Michael Jackson

Aim: Sending mixed signals

Signals
   Limited way of sending information to a process.
   kill
      Command line utility to send a signal to a process
   $ kill <PID>
      Sends signal 15 (SIGTERM) to PID
   $ kill -<SIGNAL> <PID>
      sends SIGNAL to PID
      $ kill -9 <PID>
      1 HUP (hang up)
      2 INT (interrupt)
      3 QUIT (quit)
      6 ABRT (abort)
      9 KILL (non-catchable, non-ignorable kill)
      11 SEGV (seg fault)
      14 ALRM (alarm clock)
      15 TERM (software termination)
   kill all [-<SIGNAL>] <PROCESS>
      Sends SIGTERM (or SIGNAL if provided) to all processes with PROCESS as the name

Signal handling in c programs <signal.h>
   kill
      Sends a signal to a process in a c program
      kill(<PID>, <SIGNAL>)
      Returns 0 on success or -1 (errno) on failure.
   sighandler
      To work with signals in a c program you must create a signal handling function.
      Some signals (like SIGKILL) cannot be caught.
     
      static void sighandler( int signo ) {
         if (signo = SIGINT)
   	    printf("HOW RUDE\n");
      }
      
      Must be statics, must be void, must take a single int parameter.
      Static functions can only be run from the file it is written in, not in stack

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/1/15

SOTD: Say it aint so - Weezer

Aim: You want the signal? You can't handle the signal!

Static functions have to be written in the same file with main, cannot be included from another header

inside main:
       signal(<Signal to catch>, <function that deals with the signal>)
       signal(SIGINT, sighandler); 

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/3/15

SOTD: Imagine - John Lennon

Aim: Sharing is caring!

Do Now: Write a simple c program that creates a child process and have the parent wait for the child to exit. 
Create a primitive variable in the parent before forking, then modify that variable in the child and print it out in both the child and parent.

Shared Memory - <sys/shm.h>, <sys/ipc.h>, <sys/types.h>
   A segment of heap memory that can be accessed by multiple processes.
   Shared memory is accessed via some key that is known by any process that needs to access it.
   Shared memory does not get released when a program exits.
   5 Shared memory operations:
      Create the shared segment (happens once)
      Access the segment (happens once per process)
      Attach the segment to a variable (once per process)
      Detach the segment from a variable (once per process)
      Remove the segment (happens once)

   shmget
      Create or access a shared memory segment.
      Returns a shared memory descriptor (similar idea to a file descriptor), or -1 if it fails.
      shmget( key, size, flags )
         key
	    Unique integer identifier for the shared memory segment.
	 size
	    How much memory to request
	 flags
	    Includes permission for the segment.
	    Combine using bitwise or
	    IPC_CREAT: create the segment; if the segment is new, will set value to all 0s
	    IPC_EXCL: Fail if the segment already exists and IPC_CREAT is on
   shmat 
      Attach a shared memory segment to a variable.
      Returns a pointer to the segment, or -1(errno).
      shmat( descriptor, address, flags )
         descriptor
	    The return value of shmget
	 address
	    If 0, the OS will provide the appropriate address
	 flags
	    Usually 0, there is one useful flag
	    SHM_RDONLY: makes the memory read only      


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/4/15

SOTD: Plush - Stone Temple Pilots

Aim: Memes

Shared Memory!
   ftok
      Generate a key for IPC functions
      ftok(path,x);
         path
 	    A path to some file, the file must be accessible by the program running.
	 x
	    An int
      The generated key will be the same if path and x are the same for seperate calls
   sd = shmget( ftok("dir/file", 12), 1024, IPC_CREAT | 0664);
  
   shmdt
      Detach a variable from a shared memory segment.
      Returns 0 if successful or -1 upon failure.
      shmdt(pointer);
         pointer
	    The address used to access the segment
   
   shmctl
      Perform operations on the shared memory segment.
      Each shared memory segment has metadata that can be stored in a struct (struct shmid_ds)
      Some of that data stored: last access, size, pid of the creator, pid of the last modification
      shmctl( descriptor, command, buffer );
         descriptor 
	    Return value of shmget
	 commands
	    IPC_STAT
	       populate the buffer (struct shmid_ds) with information
	    IPC_SET
	       set some of the information for the segment to the info in the buffer
	    IPC_RMID
	       remove a shared memory segment
      e = shmctl( sd, IPC_RMID, NULL );
   
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/7/15

SOTD: The General - Dispatch

Aim: How do we flag down a resource?

Semaphores (created by Edsgar Dijkstra)
   IPC construct used to control access to a shared resource (like a file or shared memory).
   Essentially, a semaphore is a counter that represents how many processes can access a resource at any given time.
      If a semaphore has a value of 3, then it can have 3 active "users".
      If a semaphore has a value of 0, then it is unavailable.
   Most semaphore operations are "atomic", meaning that they will not be split up into multiple processor instructions.
   Semaphore operations:
      Create a semaphore
      Set an initial value
      Up(S) / V(S)
         Release the semaphore to signal you are done with it's associated resource.
	 pseudocode:
	    S++
      Down(S)/ P(S)
         Attempt to take the semaphore.
	 If the semaphore is 0, wait for it to be available
	 pseudocode:
	    while(S == 0) 
	       block
 	    S--
   Removing a semaphore
      
Semaphore code
   semget - <sys/types.h>, <sys/ipc.h>, <sys/sem.h>
      Create/Get access to a semaphore.
      This is not the same as Up(S), the semaphore is not modified by semget.
      Returns a semaphore descriptor or -1 (errno)
      semget( <KEY>, <AMOUNT>, <FLAGS> )
         KEY
	    Unique semaphore identifier (use ftok)
	 AMOUNT
	    Semaphores are actually stored as sets with possibly many semaphores stored together. This parameter sets the number of semaphores to create/get.
	 FLAGS
	    Includes permissions for the semaphore.
	    Combine with bitwise or
	    IPC_CREAT: create the semaphore, will set values to 0
	    IPC_EXCL: Fail if the semaphore alread exists and IPC_CREAT is on.
	 example
	    int semd;
	    semd = segment( ftok("file/dir", 2), 1, 0664 | IPC_CREAT );

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/8/15

SOTD: Time is Running Out - Muse
Aim: What's a semaphore? - To control resources!

Semaphore code
   semctl - <sys/types.h> <sys/ipc.h> <sys/sem.h>
      Control the semaphore, including:
         Set the semaphore value
	 Remove the semaphore
	 Get the current value
	 Get information about the semaphore
      semctl(<DESCRIPTOR>, <INDEX>, <OPERATION>, <DATA>)
         DESCRIPTOR
	    The return value of semget
	 INDEX
	    The index of the semaphore you want to control in the semaphore set identified by the descriptor
	    For a single semaphore set, 0.
	 OPERATION
	    One of the following constants (there are others as well)
	    IPC_RMID: remove the semaphore (does not need DATA)
	    SETVAL: set the value (requires DATA)
	    SETALL: set the value of every semaphore in the set (requires DATA)
	    GETVAL: Return the value
	    IPC_STAT: Populate the buffer with information about the semaphore (requires DATA)
         DATA
	    Variable for setting/storing information about the semaphore (data type: union semun)
	    You have to declare this union in your main c file on linux machines.
	    union semun {
	       int val;
	       struct semid_ds *buf;
	       unsigned short *array;
	       struct seminfo *__buf;
	    };
	    val: used to set initial value
	    buf: buffer for IPC_STAT
	    Union is only as large as the largest data structure inside   
	    

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/8/15

SOTD: Bold As Love - Jimi Hendrix

Aim: Turn down or up?

Semaphore code
   semop
      Perform semaphore operations (like Up/Down)

      All operations performed via semop are atomic!
      semop( <DESCRIPTOR>, <OPERATION>, <AMOUNT> )
         AMOUNT
	    The amount of semaphores you want to operate on in the semaphore set.
	    For a single semaphore set, 1.
	 OPERATION
	    A pointer to a struct sembuf value
	    struct sembuf {
	       short sem_op;
	       short sem_num;
	       short sem_flg;
	    };
	    sem_num
	       The index of the semaphore you want to work on.
	    sem_op
	       -1: Down(S)
	       1: Up(S)
	       Any -/+ number will work, you will be requesting/releasing that value from the semaphore.
	       0: Block until the semaphore reaches 0	    
	    sem_flg
	       Provide further options
	       SEM_UNDO:
	          Allow the OS to undo the given operations. Useful in the event that a program exits before it could release a semaphore.
	       IPC_NOWAIT:
 	          Instead of waiting for the semaphore to be available, return an error.
	     	  
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/14/15

SOTD: Shinbone Alley/Hard to Exist - Spin Doctors

Aim: Ceci n'est pas une pipe

Pipe
   A conduit between 2 seperate processes.
   Pipes have 2 ends, a read end and a write end.
   Pipes are unidirectional (a single pipe must be either read or write only in a process).
   Pipes act just like files.
   You can transfer any data you like through a pipe using read/write.
   Unamed pipes have no external identification (like a descriptor or name).
   
   pipe - <unistd.h>
      Create an unnamed pipe.
      Returns 0 if the pipe was created, -1 if not.
      Opens both ends of the pipe as files.
      pipe (int descriptors[2])
         descriptors
	    Array that will contain the descriptors for each end of the pipe.
	    fd[0] generally read and fd[1] write

Named Pipes
   Also known as FIFOs.
   Same as unnamed pipes except FIFOS have a name that can be used to identify them via different programs.
   Keep in mind that like unnamed pipes, FIFOs are unidirectional.
   
   mkfifo - <sys/types.h> <sys/stat.h>
      Shell command to make a FIFO
      $ mkfifo <pipe name>
        
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/15/15

SOTD: Tropicalia - Beck

Aim: A pipe by any other name...

   mkfifo
      returns 0 on success and -1 on failure
      once created, the FIFO acts like a regula file, and we can use open, read, write and close on it.
      mkfifo( <name>, <permissions> )
      FIFOs will block on open until both ends of the pipe have a connection.
      needs read and write end
   remove(<filename>);
      remove("mario");

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/16/15

SOTD: Cantaloop - US3 (Cantaloupe)

Aim: Always remember to tip your servers

Server/Client Program Paradigms
   Handshake
      A procedure to ensure that a connection has been established
      Both ends of the connection must verify that they can send and receive data to and from each other
      Basic Handshake procedure:
         1) Server creates a named piped (Well Known Pipe)
	 2) Server waits for a connection
         3) Client creates a "private" named pipe 
	 4) Client connects to server through WKP and sends the name of the private pipe
	 5) Client connects to the private pipe, waiting for the server
	 6) Server receives client's messages and removes the WKP
	 7) Server connects to client pipe, sending an initial acknowledgement message.
	 8) Client receives the server's message, removes its private pipe.
	 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/17/15

SOTD: The Joker - Steve Miller Band

Aim: You just got served!

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

12/18/15

SOTD: The last 8 songs on Abbey Road - The Beatles

Aim: Sometimes you have to ask your server for another fork.



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////